---
title: "패키지 매니저로 CI 최적화하기(with. pnpm, yarn berry)"
date: "2025-04-02"
description: "CI/CD 파이프라인은 크게 다섯 단계로 이루어지며 특히 빌드 단계가 오래걸린다. npm install로 몇 분씩 잡아먹기도 하고, Typescript의 경우 JS로 트랜스파일된 후 번들링까지 거쳐야하므로 시간이 길어진다. 대부분의 CI/CD 환경은 Docker 기반이기 때문에 배포 때마다 설치와 빌드 과정을 반복하고, 협업 인원이 많을수록 비용은 n배수로 증가할지 모른다. 따라서, 이번 게시글은 반복적으로 발생하는 설치/빌드 작업을 효율적으로 운영할 수 있느냐는 곧 CI 최적화의 기본이자 핵심이 아닐까하는 생각으로 고민을 시작해본다."
thumbnail: "thumbnail.png"
category: "Productivity"
subcategory: "CI/CD"
tags: []
---

## 들어가며

CI/CD 파이프라인은 크게 다섯 단계로 이루어진다. `코드 푸시`와 `빌드`, `테스트`, `배포`, 그리고 `모니터링` 단계로 구성되며, 특히 빌드 단계가 오래걸린다. `npm install`로 몇 분씩 잡아먹기도 하고, Typescript의 경우 JS로 트랜스파일된 후 번들링까지 거쳐야하므로 시간이 길어진다. 대부분의 CI/CD 환경은 Docker 기반이기 때문에 배포 때마다 설치와 빌드 과정을 반복하고, 협업 인원이 많을수록 비용은 n배수로 증가할지 모른다. 따라서, 이번 게시글은 반복적으로 발생하는 설치/빌드 작업을 효율적으로 운영할 수 있느냐는 곧 CI 최적화의 기본이자 핵심이 아닐까하는 생각으로 고민을 시작해본다.

## 어떻게 하면 설치와 빌드 속도를 줄일 수 있을까

당연하게도 해답은 설치와 빌드를 담당하는 툴에 있다. 기본적으로 Javascript 생태계는 모듈 시스템 기반으로 돌아가고, 개발자들이 개발하는 방식은 외부 패키지를 내려받아 사용하는 구조이기 때문에 우리는 결국 이 사이클의 생산성과 직결되는 **패키지 매니저** 를 통해 최적화를 시도할 수 있다.

패키지 매니저가 하는 일은 정리해보면 다음과 같다.

- **의존성 관리 복잡성 해결** : 프로젝트 규모가 커질수록 의존하는 패키지 수와 복잡도가 즐가하기 때문에 이러한 수많은 의존성을 자동으로 해결하고 충돌을 방지한다.

- **버전 일관성 유지**: 팀 내 모든 개발자가 동일한 패키지 버전을 사용하도록 보장되어 환경 차이로 인한 오류를 방지한다.

- **개발 효율성 향상**: 간단한 명령어로 설치, 업데이트하여 개발 속도를 빠르게 한다.

그렇다면, 가장 기본적이면서 오래된 구식(?)의 패키지 매니저인 npm부터 차례로 알아보자. 패키지 매니저는 크게 네 가지로 나뉜다.

1. **NPM(Node Package Manager)**
2. **Yarn Classic(v1)**
3. **Pnpm(Performant NPM)**
4. **Yarn Berry(v2+)**

![npm vs yarn](1.png)

### npm

2010년에 등장한 최초의 JS 패키지 매니저로, Node.js와 함께 배포된다. `node_modules` 폴더에 모든 의존성을 중첩으로 설치하고 패키지를 하나하나 돌면서 `node_modules`에 보관시키기 때문에 기본적으로 무겁고, 특정 모듈을 탐색하는 과정도 병렬 처리가 없기에 강력한 접근이지만 비효율적이다. 즉, `package.json` 파일로 패키지 메타데이터를 관리하고, `node_modules` 디렉토리에 패키지를 설치한다.

### yarn classic

2016년, Facebook(현 Meta)과 Google 등의 협업으로 만들어진 Yarn은 npm의 성능 및 보안 문제를 개선하기 위해 만들어졌다. 병렬 설치와 `yarn.lock` 파일을 통해 더 빠르고 안정적인 설치를 지원하며, 기존에 시멘틱 버저닝 방식에서 `^(캐럿)`을 통해 서로 다른 환경에서 버전 일관성이 되지 않는 문제를 해결하고자 모든 의존성 버전을 `lock` 파일에 고정하여 개선시켰다. 하지만 여전히 `node_modules` 구조를 유지하기 때문에 구조적인 한계는 존재하고, 특히 **유령 의존성** 문제가 발생한다.

#### npm에도 `package-lock.json`이 있지 않나?

맞다! `npm`은 `package-lock.json`, `yarn`은 `yarn.lock`이라는 Lockfile로 의존성을 고정한다. 다만, 내부 동작의 차이가 있다. `package-lock.json`은 `JSON`형태인 반면, `yarn.lock`은 `YAML`형태로 읽기 쉬운 텍스트로 구성되어있고, `package-lock.json`은 설치 시점에 맞게 유연하게 결정되는 반면 `yarn.lock`은 적힌 버전을 그대로 설치한다. 따라서, `yarn.lock`은 더 엄격하게 의존성을 관리한다.

---

#### npm과 yarn classic의 단점

#### 1. 여전히 너무나 큰 `node_modules`

프로젝트 규모가 커짐에 따라 `node_modules`가 구조적으로 비대해지는 것은 불가피했고, 그렇기 때문에 파일 탐색 속도가 느려질 수 밖에 없다.

#### 2. 유령 의존성

`node_modules`에는 `package.json`에 명시된 라이브러리들이 저장되는데, 각 라이브러리에도 독자적인 `package.json`이 존재하고, 이 `package.json`에 명시된 `dependencies`는 각각 해당 라이브러리가 저장된 디렉토리 하위에 `node_modules`를 또 만들어 저장한다.

여기서 문제가 발생한다! 복수의 라이브러리에서 동시에 같은 버전의 라이브러리를 `dependency`로 사용하고 있다면, 해당 라이브러리는 `node_modules`의 최상위 경로롤 끌어올리는데(여기서도 이를 호이스팅이라고 부른다), 이 때 간접 설치한 종속성에 개발자가 접근할 수 있게 되는 상황이 발생하기도 한다. 즉, 존재하지 않는 종속성에 의존하는 코드가 발생할 수 있다는 위험한 이야기다.

- 단, 여기서의 호이스팅은 패키지 최상위에서 트리 깊이 탐색을 하지 않고 루트 경로에서 원하는 패키지를 탐색하기 때문에 방식 자체는 효율적이다.

![](2.jpg)

예를 들어, C 패키지가 A에 의존하고 A가 B를 사용하는 상황이라고 가정하자. 이 때, C는 B를 의존하지 않지만, A를 통해 B가 설치되어 있기 때문에 B를 `import`해도 오류없이 동작한다. 하지만 만약 A가 제거되거나 B를 더 이상 사용하지 않게 되면, C는 B가 필요하다고 착각하고 있던 의존성을 잃어버리는 문제가 발생하는 것이다.

---

### pnmp

![](3.jpg)

2017년에 출시된 pnpm은 디스크 공간 효율성과 설치 속도를 높이기 위해 나온 패키지 매니저다. Performant npm을 가리키는 이름만 보아도 알 수 있는 pnpm의 특징은 다음과 같은 특징을 가진다.

#### 1. 콘텐트 주소 지정 저장소(Content-Addressable Storage)

pnpm은 동일한 패키지를 전역 저장소에 한 번만 저장하고, 프로젝트에서는 이 저장소를 참조하는 링크만 남기도록 동작시킨다. 패키지의 내용(content)을 해싱하여 저장 경로를 결정하기 때문에, 동일한 패키지가 중복 설치되지 않고 한 번만 저장된다. 예를 들어, 10개 프로젝트가 모두 `lodash`를 사용하더라도 실제로 디스크에 설치되는 `lodash`는 하나뿐이다.

![](4.jpg)

즉, 위 사진처럼 동일한 패키지를 **전역 저장소(Content-Addressable Storage)**에 **한 번만 저장**하고 프로젝트(`projcet_1`, `project_2`)에서는 링크로서 **참조**하도록 한다.

#### 2. 하드 링크와 심볼릭 링크의 조합

전역 저장소에서 실제 패키지를 **하드 링크**로 연결하여 디스크 사용량을 최소화시킨다. 즉, 프로젝트에 설치된 패키지는 복사본이 아니라, 전역 저장소에 존재하는 실체를 참조하는 방식이다. 이를 통해 설치 속도는 빨라지고 디스크 공간은 절약될 수밖에 없다.

그렇다면 심볼릭 링크는 뭘까? 프로젝트 내에서 패키지 간 의존성 트리를 구성할 때, 이 **심볼릭 링크(symlink)**를 사용한다. 예를 들어, A가 B를, B가 C를 의존한다면, pnpm은 이 구조를 **symlink**로 명확하게 구성하여 의존성 충돌을 방지하고 격리된 환경을 제공한다.

#### 3. `node_modules` 구조의 혁신 !

pnpm은 전통적인 `node_modules`의 중첩 구조를 `.store` 라는 디렉토리에 하드 링크된 패키지를 저장하고, `.pnpm` 내부에서 `symlink`로 패키지 간 관계를 정리한 뒤 `node_modules`에 필요한 구조만 노출시킨다. 이러한 방식 덕분에 우리는 **유령 의존성 문제를 방지**할 수 있고, 의존성 명시에 대한 명확성과 성능, 디스크 효율성 모두 동시에 잡을 수 있게 된다!

### yarn berry

![](5.jpg)

pnpm까지 완벽해보이는데 yarn berry는 뭘까? pnpm은 실제로 대규모 프로젝트나 모노레포 환경에서 디스크 효율성과 의존성 충돌 방지에 뛰어난 성능을 보여준다는 이야기가 참 많다. 리서치한 내용으로는, yarn berry는 좀 더 빠른 패키지 설치 속도와 유령 의존성 완전 제거, 그리고 `node_modules` 자체를 없애는 구조적인 혁신으로 pnpm보다 한발 더 앞서 있다.

2020년에 발표된 yarn의 차세대 버전인 yarn berry는 `node_modules`를 없앨 뿐더러 **Plug'n'Play(PnP)**라는 새로운 방식으로 의존성을 로딩한다. 이 덕에 속도가 더욱 줄고, 패키지 간 경로 탐색이 완전히 필요가 없어졌다. 즉, 패키지를 실제 디스크에 풀어놓지도 않고도 실행이 가능한 것이다!

아래 사진은 항목별과 패키지 매니저별로 성능 벤치마킹한 그래프인데, 먼저 npm은 쓰면 안되겠다는 생각부터 들지 않을까 싶다. pnpm도 엄청난 성능을 보여주지만 yarn berry가 더욱 뛰어난 성능을 보여주는 걸 알 수 있다.

![pnpm vs yarn berry with benchmark / github](6.png)

#### 1. Plug'n'Play(PnP)

`node_modules`를 아예 사용하지 않는 대신, `.pnp.cjs`라는 하나의 파일에 패키지 위치와 의존성 정보를 모두 담아두고, Node.js의 모듈 해석 로직을 재정의해 필요한 패키지를 직접 로드하는 방식을 제공한다.

#### 2. 커스텀 Node.js 로더 사용

패키지를 메모리처럼 직접 참조할 수 있어 속도와 안전성이 높다. 기존의 파일 시스템 기반 탐색이 아닌 `.pnp.cjs`에 기록된 정보를 바탕으로 의존성을 추적한다.

#### 3. zip 파일 기반의 `zipFS` 사용

설치된 패키지를 압축(zip) 형태로 유지한 채, 압축을 해제하지 않고 바로 읽어오는 **zip 파일 시스템(`zipFS`)**를 활용하여 디스크 I/O를 줄여 성능을 극대화했다.

#### 4. 플러그인 시스템

yarn 자체에 필요한 기능을 커스텀 플러그인 형태로 확장하여 팀의 요구사항에 맞춘 유연한 환경 구성이 가능하다.

즉, `pnppm`도 빠르고 가볍지만 기존의 파일 기반 의존성 관리 방식이라는 전통적인 한계가 있기에 `yarn berry`는 `node_modules` 구조를 아예 버리고, 의존성을 가상화하여 더 빠르고 안전하며 확장 가능한 환경을 만든다.

npm, pnpm, yarn 별 속도 비교 스크린샷 첨부. yarn berry + nodeLinker: pnpm 적용 후 성능 비교 중

...
