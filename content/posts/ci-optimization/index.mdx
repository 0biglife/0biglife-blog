---
title: "CI 최적화(with. pnpm, yarn berry)"
date: "2025-04-01"
description: ""
thumbnail: "thumbnail.png"
category: "Productivity"
subcategory: "CI/CD"
tags: []
---

## 들어가며

목표 : CICD 파이프라인을 더 빠르게 만들어보기

CI/CD 파이프라인 : 5가지 중 코드 푸시, 빌드, 테스트가 가장 오래 걸리기에 많은 개발자들이 이 단계들ㅇ르 최적화하려고 함.
왜? 프로젝트 받거나 내 로컬에 띄워 개발할 때, 기본적으로 패키지 설치(npm -> nest는 5분 + 업데이트 )

패키지 무거워질 때 중요한 점은, 모던 CI/CD 환경이 도커 같은 가상화된 컨테이너 기반으로 이루어진게 대부분. 프론트나 백은 설치, 빌드 실행까지 마치고 애플리케이션이 배포가됨. 매번 배포, 통합 때마다 매번 이 워크플로우가 돌아가는 시간이 길어질수록 10분씩 기다려야한다거나 하면 하나의 프로젝트가 오래걸린다는 것은 많은 개발자들이 협업하는 환경에서는 n배수로 더 커질 수 있다. 그래서 이 빌드타임, 인스톨레이션 타임을 줄이려고함.

가장 오래 걸리는 것 크게 1. install(의존성 분석 설치 과정), 2. build(TS라면 기본적으로 law code로 변환되는 언어가 아니고 js로 트랜스파일되고 그 다음에 어플리케이션이 됨) 이 과정을 거쳐서 번들 파일이 만들어지는 과정이 CI에서 시간을 많이 잡아먹는 과정.

그러기에 빌드 툴이 이를 어떻게 개선시켜줄 수 있을지 고민해본다. 어떻게 접근?

---

JS는 모듈 시스템 지원함. 패키지 같은걸 다운 받아서 특정 기능을 라이브러리 형태로 빌려오는 형태의 개발. 이 모듈, 여러 모듈을 상자처럼 담아둔걸 패키지라고하고, 개발자는 이 패키지를 next, nest 등등 으로 개발.

의존성은 어떤 패키지를 몇 버전을 어디서 받는걸 의존성이라고 함

우리는 많은 의존성을 관리해야함

보통 package.json 안에 정보를 보고 insrtall하여 node modules 폴더에 넣어서 사용을 함

패키지 매니저는 require 또는 import 구문을 통해 외부 패키지를 사용(이는 어디에 저장되어있는지 가리키고 탐색하는 역할)

js 패키지 매니저는 크게 npm, yarn classic, pnpm, yarn berry

npm은 node packag manager.
node는 chrome의 V8 엔진에다가 팔다리를 붙여서 어떤 환경에서 js를 실행할 수 있게하자로 해서 만들고, js는 commonJs라는 모듈 시스템을 만들고, js 생태계 틀을 만듬

2010년(이거 맞나 ㅈ날짜?)도까지는 거의 npm만 쓰고 표준이 됨
이 모듈을 따는 파일, 즉 node의 모듈들을 담고 있는 node_modules가 생기게 됨

npm은 구식임. 단순한 구조임. 패키지를 하나하나 돌면서 node module에 하나씩 때려넣음. 그렇게 때문에 기본적으로 무겁고, 특정 모듈을 탐색하는 과정도 하나씩 조회하기 때문에 병렬처리없이 단순하지만 강력한 접근임.

그래서 2016년 facebook(meta), google 등 협업으로 yarn 등장.
주요 개선점은 설치를 병렬로 하고, 기존 시멘틱 버저닝 방식(^18.0.0, ^는 캐럿이라고 하고, 18.x.x안에서 최신을 깔겠다 라는 의미. 이는 설치시 버전이 동적으로 결정된단느 의미. 원래는 18.0.0에서 18.1.0에서 BC라는 breaking change가 발생하면 안됨)을 개선해주는 lock 파일 생김.

lock 파일을 통해 당시 설치한 버전과 동일한 버전에 대한 안정성 확보 + 속도 개선(왜 개선되지?)

yarn 1.22.22를 yarn classic이라고 부르고, 속도면에서 빠름

yarn classic 단점은 여전히 무거운 node modules.
두 번째 단점은 유령 의존성을 가짐.
A패키지에서 B를 쓰고 있고 C에서 A를 쓰고 있으면 C에서도 A,B를 모두 가지고 있어야해서 한 번만 가지고 있어야하는 상황에.
이걸 위해서 호이스팅(웬만해서 끌어올리는 동작은 호이스팅이라고 함) 을 통해 해결. 다만 다른 버전의 자식 패키지에서는 중복이 발생. 이 경우를 유령 의존성이라고 함

pnpm은 performant npm (효율적인 npm)
어떤 효율을 하냐, 바로 중복을 제거함. 동일한 패키지를 전역 저장소에 한 번만 저장하고, 프로젝트에서는 심볼릭 링크로 참조함.
그리고 설치 시에는 공용 저장소에서 있는 하드 링크를 참조해서 디스크 공간 자체를 절약하고, 설치 속도를 향상시킴
이 두 장점을 이용해서 의존성 격리가 가능해짐. 즉, 패키지 간 의존성을 명확하게 분리하여 충돌을 방지함

- 동작 원리와 하드 링크

pnpm는 npm과 거의 충돌이 없음. pnpm이 아직까지 이슈가 생겨서 기존 레거시 콜랙터가 터져서 못쓰거나 한 적은 없는걸로 알고 있음. 따라서, pnpm

---

yarn berry는 2020년에 나온 yarn의 차세대 버전, 혁신적 기능 도입하여 패키지 관리의 새로운 패러다임을 제시.
어떤게 혁신적이냐. node modules를 지워버림. node modules에 의존성 설치하는 방식 자체를 갈아치움

더 효율적인 방법은 zip을 통해 패키지를 받고, zip을 읽는 zip file system을 사용해서 패키지를 읽어오고 native module loader를 써서 패키지를 로드하여 의존성 관리함. 현존하는 패키지 매니저중에 제일 빠르고 효율적이라는 평가 받음

혁신적인 기능 특: 요류 개많음. but, 빨랐죠? 유의미하게 빠름.

---

모든 패키지 매니저 단계: 설치하는 과정을 유심히 보면 세 단계가 보임. 특히 yarn은 직접 보여줌

1. Resolution 단계

패키지의 정확한 버전을 결정하고, 의존성 트리를 구축(호이스팅이런거), 즉 실제 패키지를 재귀적으로 탐색하면서 어떤 패키지가 필요한지 정하고 버전을 결정하고 lock 파일까지 생성시킴. 이 단계가 시간 오래걸림. lock 파일이 있으면 빠르게 지나감

2. Fetch 단계

결정되 ㄴ의존성을 다운로드하는 과정

3. Link 단계

포인터, 주소 개념이 여기서 나옴.
다운로드된 패키지를 프로젝트에서 사용할 수 있도록 연결함. 이 단계에서 패키지 매니저마다 다른 방식을 사용함.
링크는 쉽게 말하면 포인터. 어디를 가리키냐에 따라서 심볼링 링크, 하드 링크가 되는데

- npm의 Linking 방식 : 기본적으로 node moudles 안에 실제 패키지가 다 받아져있는 폴더 탐색 링크를 가짐. 실제 파일 시스템을 이용하는 링킹. 그러기 때문에 디스크 사용량이 많음

- pnpm은 두가지 링킹 방식. 하드 링크와 심볼릭 링크를 사용함

하드 링크는 pnpm은 패키지를 선택할 때 중복해서 설치하지 않고, 전역 저장소에 한 번만 저장함. 그 후에 각 프로젝트는 이 저장소에 저장된 패키지를 하드 링크를 통해 참조함. 하드 링크는 동일한 팡리 여러 개 참조가 가능하기에 디스크 사용량이 크게 절감됨. (일종의 바로가기 로 보면 됨) 예를 들어, 내 컴퓨터에 .pnpm을 만들어서 거기에 전역 저장소에 들어갈 모든 패키지를 저장함.

심볼릭 링크는 패키지 내에서 패키지 간의 의존성 트리를 구성할 때 사용되는 링크. react가 있으면 실제 패키지가 아닌 들어가있는 폴더 주소, 즉 심볼릭 ㅅ링크를 가리키면 실제 설치된 패키지가 연결되어있음(부연 설명 필요할듯. 애매하네 설명이)

확인하는 법 : node modules 열면 폴더 우측 화살표 아이콘이 있으면 링킹 되었다는 뜻. 누르면 열리고 심볼릭 링크를 커서 대면 나옴.

- yarn은 좀 다름. .pnp.cjs 안에 패키지 위치와 버전 정보를 모듈처럼 넣어둠. 얘를 로드해서 직접 노드의 모듈 로더를 이용해서 패키지를 로드함. react 같은 패키지를 객체의 id 값을 참조하듯이 path를 통해 가져오는 인터페이스 링크 방식이라고 함. 게다가 압축까지 하기 때문에 더욱 작은 형태를 가짐

어마어마한 속도차이 (밴치마크 사진)
보면 npm을 쓸 이유가 전혀 없어보인다.

- core pack은 무엇?

---

yarn berry 설치 및 Npm 에서 마이그레이션 방법

1. ocre pack 설치

설치 되었는지 확인 방법.

vscode의 extension 설치해야함. zipFS라는 확장 프로그램을 설치하면 .zip 파일을 읽을 수 있음. 이걸 설치하면 yarn berry가 설치되어있는지 확인 가능

---

yarn과 pnpm의 다른 부분은 링킹 부분.

yarn이 젤 빠르기에 yarn을 쓰되 링킹만 npm과 잘 연동되도록 쓰고 싶다면? // 가장 좋은 최적화 방법인지?

yarn doc (https://yarnpkg.com/features/linkers) 참고하면, 현존하는 가장 좋은 가장 좋은 패키지 매니저 스택. yarn berry를 쓰면서 nodeLinker를 pnpm으로 쓰는 것. 이렇게 하면 yarn berry의 속도와 pnpm의 효율성을 모두 쓸 수 있음.

## 마치며

~~ 정리. 비즈니스 임팩트가 클지도 모른다. 이런 기술에 대해 깊이 알고 있어야 차세대 기술이 나올 때 빠르게 어느 부분이 바뀐지 알고 넘어갈 수 있겠다. 이번 게시글을 통해 CI 중에 극히 일부인 패키지 매니저에 대한 이야기였다. 물론 k8s 도커 aws 배포, cicd를 github actions로 돌려서 프로젝트 배포도 좋지만 이런 근본적인 환경을 개선하는 기술들, 환경을 구성하는 기술에도 관심을 가져보면 좋겠단 생각으로.

그 다음이, 인스톨헀고 개발까지 한 뒤 개발 과정에서 코드를 실행하고 빌드해주는 녀석들 두 가지가 남아있다. 트랜스파일러와 번들러에 대해서도 다뤄보자. 타입스크립트 트랜스파일러, 컴파일이 go로 변경될거라는 최근 뉴스 첨부해서, 우리는 빌드타임, 로드 타임을 줄이는걸 관심을 두자. 필요하기에.
